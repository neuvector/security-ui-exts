import { shallowMount, flushPromises } from '@vue/test-utils';
import registries from '../RegistriesConfiguration.vue';

describe('registries.vue', () => {
  let storeMock: any;
  let routerMock: any;

  beforeEach(() => {
    // mock Vuex store
    storeMock = {
      dispatch: jest.fn(),
      getters: {
        'cluster/all': jest.fn().mockReturnValue([]),
        'cluster/canList': jest.fn().mockReturnValue(true),
        'cluster/schemaFor': jest.fn().mockReturnValue({}),
        'prefs/get': jest.fn().mockImplementation((key) => {
          if (key === 'DATE_FORMAT') return 'YYYY-MM-DD';
          if (key === 'TIME_FORMAT') return 'HH:mm:ss';
        }),
      },
    };

    // mock Vue Router
    routerMock = {
      push: jest.fn(),
    };
  });

  function factory() {
    return shallowMount(registries, {
      global: {
        mocks: {
          $store: storeMock,
          $router: routerMock,
          $route: { params: { cluster: 'c-abc' } },
          t: (msg: string) => msg, // mock i18n
        },
        stubs: {
          SortableTable: { template: '<div><slot/></div>' },
          RecentUpdatedRegistries: true,
          StatusDistribution: true,
          ScanButton: true,
        },
      },
    });
  }

  it('renders the title correctly', () => {
    const wrapper = factory();
    expect(wrapper.find('.title').text()).toBe('imageScanner.registries.title');
  });

  it('calls loadData when refresh is clicked', async () => {
    const wrapper = factory();
    const refreshSpy = jest.spyOn(wrapper.vm, 'loadData').mockResolvedValue();

    await wrapper.find('button[aria-label="Refresh data"]').trigger('click');
    expect(refreshSpy).toHaveBeenCalled();
  });

  it('navigates to create registry when Create is clicked', async () => {
    const wrapper = factory();
    await wrapper.find('button[aria-label="Add new"]').trigger('click');

    expect(routerMock.push).toHaveBeenCalledWith({
      name: 'imageScanner-c-cluster-resource-create',
      params: {
        resource: 'sbombastic.rancher.io.registry',
        cluster: 'c-abc',
        product: 'imageScanner',
      },
    });
  });

  it('updates rows after loadData', async () => {
    const wrapper = factory();

    storeMock.getters['cluster/all']
      .mockReturnValueOnce([{ metadata: { name: 'reg1', namespace: 'ns1' }, spec: {} }]) // registries
      .mockReturnValueOnce([]); // scanJobs

    await wrapper.vm.loadData(true);
    await flushPromises();

    // Ensure rows is typed as any[] for test purposes
    const rows = wrapper.vm.rows as any[];
    expect(rows).toHaveLength(1);
    expect(rows[0].metadata.name).toBe('reg1');
  });

  it('summarizes registry scan data correctly', () => {
    const wrapper = factory();
    const registriesCRD = [
      {
        metadata: { name: 'reg1', namespace: 'ns1', creationTimestamp: '2023-01-01T00:00:00Z' },
        spec: { uri: 'http://test.uri' },
        scanRec: { currStatus: 'complete', previousStatus: 'pending', lastTransitionTime: '2023-01-02T00:00:00Z' }
      }
    ];

    const { registryStatusList, statusSummary } = wrapper.vm.getSummaryData(registriesCRD);

    expect(registryStatusList[0].registryName).toBe('reg1');
    expect(statusSummary.complete).toBe(1);
  });
  it('updates filter status when filterByStatus is called', () => {
    const wrapper = factory();
    wrapper.vm.filterByStatus('pending');
    expect(wrapper.vm.filters.statusSearch).toBe('pending');
  });
  it('filters rows correctly by registry, namespace, uri, repository, and status', () => {
    const wrapper = factory();
    (wrapper.vm.rows as any[]) = [{
      metadata: { name: 'reg1', namespace: 'ns1' },
      spec: { uri: 'http://my-uri', repositories: ['repo1'] },
      scanRec: { currStatus: 'complete' }
    }];

    wrapper.vm.filters = {
      registrySearch: 'reg1',
      namespaceSearch: 'ns1',
      uriSearch: 'uri',
      repositorySearch: 'repo1',
      statusSearch: 'complete'
    };

    const filtered = wrapper.vm.filteredRows;
    expect(filtered).toHaveLength(1);
    expect(filtered[0].metadata.name).toBe('reg1');
  });
  it('formats latest update time correctly', () => {
    const wrapper = factory();
    wrapper.vm.latestUpdateTime = new Date('2023-01-01T12:34:56Z');
    expect(wrapper.vm.latestUpdateDateText).toContain('2023'); // year included
    expect(wrapper.vm.latestUpdateTimeText).toMatch(/\d/);     // time string
  });
  it('fetchSecondaryResources returns scan jobs', async () => {
    storeMock.dispatch.mockResolvedValueOnce([{ id: 'scanJob1' }]);
    const wrapper = factory();
    const result = await wrapper.vm.fetchSecondaryResources({ canPaginate: false });
    expect(result).toEqual([{ id: 'scanJob1' }]);
  });

  it('fetchPageSecondaryResources fetches scan jobs with pagination', async () => {
    const scanJob = { id: 'scanJob1' };
    storeMock.dispatch.mockResolvedValueOnce([scanJob]);

    const wrapper = factory();
    const result = await wrapper.vm.fetchPageSecondaryResources({
      canPaginate: true,
      force: true,
      page: [{ metadata: { namespace: 'ns1', name: 'job1' } }]
    });

    expect(storeMock.dispatch).toHaveBeenCalledWith('cluster/findPage', expect.any(Object));
    expect(result).toEqual([scanJob]);
  });
});