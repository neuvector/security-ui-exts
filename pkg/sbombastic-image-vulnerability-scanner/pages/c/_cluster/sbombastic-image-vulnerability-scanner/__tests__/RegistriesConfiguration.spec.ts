import { shallowMount, flushPromises } from '@vue/test-utils';
import registries from '../RegistriesConfiguration.vue';
import { RESOURCE } from '@pkg/types';

describe('registries.vue', () => {
  let storeMock: any;
  let routerMock: any;

  beforeEach(() => {
    // mock Vuex store
    storeMock = {
      dispatch: jest.fn(),
      getters: {
        'cluster/all': jest.fn().mockReturnValue([]),
        'cluster/canList': jest.fn().mockReturnValue(true),
        'cluster/schemaFor': jest.fn().mockReturnValue({}),
        'prefs/get': jest.fn().mockImplementation((key) => {
          if (key === 'DATE_FORMAT') return 'YYYY-MM-DD';
          if (key === 'TIME_FORMAT') return 'HH:mm:ss';
        }),
      },
    };

    // mock Vue Router
    routerMock = {
      push: jest.fn(),
    };
  });

  function factory() {
    return shallowMount(registries, {
      global: {
        mocks: {
          $store: storeMock,
          $router: routerMock,
          $route: { params: { cluster: 'c-abc' } },
          t: (msg: string) => msg, // mock i18n
        },
        stubs: {
          SortableTable: { template: '<div><slot/></div>' },
          RecentUpdatedRegistries: true,
          StatusDistribution: true,
          ScanButton: true,
        },
      },
    });
  }

  it('renders the title correctly', () => {
    const wrapper = factory();
    expect(wrapper.find('.title').text()).toBe('imageScanner.registries.title');
  });

  it('calls preprocessData when refresh is clicked', async () => {
    const wrapper = factory();
    const refreshSpy = jest.spyOn(wrapper.vm, 'preprocessData').mockResolvedValue();

    await wrapper.find('button[aria-label="Refresh data"]').trigger('click');
    expect(refreshSpy).toHaveBeenCalled();
  });

  it('navigates to create registry when Create is clicked', async () => {
    const wrapper = factory();
    await wrapper.find('button[aria-label="Add new"]').trigger('click');

    expect(routerMock.push).toHaveBeenCalledWith({
      name: 'imageScanner-c-cluster-resource-create',
      params: {
        resource: 'sbombastic.rancher.io.registry',
        cluster: 'c-abc',
        product: 'imageScanner',
      },
    });
  });

  it('updates rows after preprocessData', async () => {
    const wrapper = factory();

    (wrapper.vm.registriesCRD as any[]) = [{ metadata: { name: 'reg1', namespace: 'ns1' }, spec: {} }]; // registries
    await wrapper.vm.preprocessData();
    await flushPromises();

    // Ensure rows is typed as any[] for test purposes
    const rows = wrapper.vm.rows as any[];
    expect(rows).toHaveLength(1);
    expect(rows[0].metadata.name).toBe('reg1');
  });

  it('summarizes registry scan data correctly', () => {
    const wrapper = factory();
    const registriesCRD = [
      {
        metadata: { name: 'reg1', namespace: 'ns1', creationTimestamp: '2023-01-01T00:00:00Z' },
        spec: { uri: 'http://test.uri' },
        scanRec: { currStatus: 'complete', previousStatus: 'pending', lastTransitionTime: '2023-01-02T00:00:00Z' }
      }
    ];

    const { registryStatusList, statusSummary } = wrapper.vm.getSummaryData(registriesCRD);

    expect(registryStatusList[0].registryName).toBe('reg1');
    expect(statusSummary.complete).toBe(1);
  });
  it('updates filter status when filterByStatus is called', () => {
    const wrapper = factory();
    wrapper.vm.filterByStatus('pending');
    expect(wrapper.vm.filters.statusSearch).toBe('pending');
  });
  it('formats latest update time correctly', () => {
    const wrapper = factory();
    wrapper.vm.latestUpdateTime = new Date('2023-01-01T12:34:56Z');
    expect(wrapper.vm.latestUpdateDateText).toContain('2023'); // year included
    expect(wrapper.vm.latestUpdateTimeText).toMatch(/\d/);     // time string
  });
  it('fetchSecondaryResources returns scan jobs', async () => {
    storeMock.dispatch.mockResolvedValueOnce([{ id: 'scanJob1' }]);
    const wrapper = factory();
    const result = await wrapper.vm.fetchSecondaryResources({ canPaginate: false });
    expect(result).toEqual([{ id: 'scanJob1' }]);
  });

  it('fetchPageSecondaryResources fetches scan jobs with pagination', async () => {
    const scanJob = { id: 'scanJob1' };
    storeMock.dispatch.mockResolvedValueOnce([scanJob]);

    const wrapper = factory();
    const result = await wrapper.vm.fetchPageSecondaryResources({
      canPaginate: true,
      force: true,
      page: [{ metadata: { namespace: 'ns1', name: 'job1' } }]
    });

    expect(storeMock.dispatch).toHaveBeenCalledWith('cluster/findPage', expect.any(Object));
    expect(result).toEqual([scanJob]);
  });

  it('filters rows locally based on filters', () => {
    const wrapper = factory();
    wrapper.vm.debouncedFilters = { 
      registrySearch: 'reg1', 
      namespaceSearch: '', 
      uriSearch: '', 
      repositorySearch: '', 
      statusSearch: 'any' 
    };

    const rows = [
      { metadata: { name: 'reg1', namespace: 'ns1' }, spec: { uri: 'u1', repositories: [] }, scanRec: { currStatus: 'pending' } },
      { metadata: { name: 'reg2', namespace: 'ns2' }, spec: { uri: 'u2', repositories: [] }, scanRec: { currStatus: 'complete' } }
    ];

    const result = wrapper.vm.filterRowsLocal(rows);
    expect(result).toHaveLength(1);
    expect(result[0].metadata.name).toBe('reg1');
  });

  it('applies API filters correctly in filterRowsApi', () => {
    const wrapper = factory();
    wrapper.vm.debouncedFilters = {
      registrySearch: 'r1',
      namespaceSearch: 'ns1',
      uriSearch: 'uri',
      repositorySearch: 'repo',
      statusSearch: 'pending',
    };

    const pagination = { filters: [] };
    const result = wrapper.vm.filterRowsApi(pagination);

    expect(result.filters.length).toBeGreaterThan(0);
    expect(result.filters[0]).toBeDefined();
  });

  it('preprocessData computes status summary and registry list', async () => {
    const wrapper = factory();
    (wrapper.vm.registriesCRD as any[]) = [
      { metadata: { name: 'reg1', namespace: 'ns1', creationTimestamp: new Date().toISOString() },
        spec: { uri: 'http://uri' },
        scanRec: { currStatus: 'failed', previousStatus: 'pending', lastTransitionTime: new Date().toISOString() }
      }
    ];

    await wrapper.vm.preprocessData();

    expect(wrapper.vm.registryStatusList.length).toBeGreaterThan(0);
    expect(wrapper.vm.statusSummary.failed).toBe(1);
  });

  it('calls store dispatches and preprocessData in loadData', async () => {
    const wrapper = factory();
    const preprocessSpy = jest.spyOn(wrapper.vm, 'preprocessData').mockResolvedValue();

    storeMock.dispatch.mockResolvedValueOnce([{ id: 'reg1' }]); // for REGISTRY
    storeMock.dispatch.mockResolvedValueOnce([{ id: 'scanJob1' }]); // for SCAN_JOB

    await wrapper.vm.loadData();

    expect(storeMock.dispatch).toHaveBeenCalledWith('cluster/findAll', { type: 'sbombastic.rancher.io.registry' });
    expect(storeMock.dispatch).toHaveBeenCalledWith('cluster/findAll', { type: 'sbombastic.rancher.io.scanjob' });
    expect(preprocessSpy).toHaveBeenCalled();
  });

  it('skips SCAN_JOB fetch if canList returns false', async () => {
    storeMock.getters['cluster/canList'] = jest.fn().mockReturnValue(false);
    const wrapper = factory();
    const preprocessSpy = jest.spyOn(wrapper.vm, 'preprocessData').mockResolvedValue();

    storeMock.dispatch.mockResolvedValueOnce([{ id: 'reg1' }]); // only registry

    await wrapper.vm.loadData();

    expect(storeMock.dispatch).toHaveBeenCalledTimes(1); // only REGISTRY
    expect(preprocessSpy).toHaveBeenCalled();
  });

  it('clears keepAliveTimer on beforeUnmount', () => {
    const wrapper = factory();
    const clearSpy = jest.spyOn(global, 'clearInterval');

    wrapper.vm.keepAliveTimer = setInterval(() => {}, 1000);
    if (wrapper.vm.$options.beforeUnmount && wrapper.vm.$options.beforeUnmount[0]) {
      wrapper.vm.$options.beforeUnmount[0].call(wrapper.vm);
    }
  });

  it('updates selectedRows when onSelectionChange is called', () => {
    const wrapper = factory();
    wrapper.vm.onSelectionChange([{ id: 'row1' }]);
    expect(wrapper.vm.selectedRows).toEqual([{ id: 'row1' }]);
  });

  it('matches by name and namespace in filterRowsLocal', () => {
    const wrapper = factory();
    wrapper.vm.debouncedFilters = {
      registrySearch: 'reg1',
      namespaceSearch: 'ns1',
      uriSearch: '',
      repositorySearch: '',
      statusSearch: 'any'
    };

    const rows = [
      { metadata: { name: 'reg1', namespace: 'ns1' }, spec: { uri: '', repositories: [] }, scanRec: {} },
      { metadata: { name: 'reg2', namespace: 'ns2' }, spec: { uri: '', repositories: [] }, scanRec: {} }
    ];

    const result = wrapper.vm.filterRowsLocal(rows);
    expect(result).toHaveLength(1);
    expect(result[0].metadata.namespace).toBe('ns1');
  });

  it('uses statusSearch.value if statusSearch is an object', () => {
    const wrapper = factory();
    wrapper.vm.debouncedFilters = {
      registrySearch: '',
      namespaceSearch: '',
      uriSearch: '',
      repositorySearch: '',
      statusSearch: { value: 'pending' },
    };

    const pagination = { filters: [] };
    const result = wrapper.vm.filterRowsApi(pagination);

    // stringify and search for the filter field/value
    const serialized = JSON.stringify(result.filters);
    expect(serialized).toContain('"field":"scanRec.currStatus"');
    expect(serialized).toContain('"value":"pending"');
  });

  it('returns canPaginate from store getter', () => {
    storeMock.getters['cluster/paginationEnabled'] = jest.fn().mockReturnValue(true);
    const wrapper = factory();

    expect(wrapper.vm.canPaginate).toBe(true);
    expect(storeMock.getters['cluster/paginationEnabled']).toHaveBeenCalledWith({ id: 'sbombastic.rancher.io.registry' });
  });

});