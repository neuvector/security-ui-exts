<template>
  <div class="page">
    <div class="header-section mb-20">
      <div class="title">
        {{ t("imageScanner.images.title") }}
      </div>
      <div class="filter-dropdown">
        <LabeledSelect
          v-model:value="selectedCveFilter"
          :options="filterCveOptions"
          :close-on-select="true"
          :multiple="false"
          disabled
          @selecting="changeCveFilter"
        />
      </div>
      <div class="filter-dropdown">
        <LabeledSelect
          v-model:value="selectedImageFilter"
          :options="filterImageOptions"
          :close-on-select="true"
          :multiple="false"
          disabled
          @selecting="changeImageFilter"
        />
      </div>
      <div>
        <button
          mat-button
          class="btn role-primary"
          aria-label="Download full report"
          type="button"
          @click="openAddEditRuleModal()">
          <i class="icon icon-download"></i>
          {{ t('imageScanner.images.downloadReport') }}
        </button>
      </div>
    </div>
    <!-- <div class="summary-section">
      <TopRiskyImagesChart v-if="preprocessedDataset.topRiskyImages" :topRiskyImages="preprocessedDataset.topRiskyImages"/>
      <ImageRiskAssessment v-if="preprocessedDataset.chartData" :chartData="preprocessedDataset.chartData" :filterFn="filterBySeverity"/>
    </div> -->
    <div class="search-filters">
      <div class="filter-row">
        <div class="filter-item">
          <label>{{ t('imageScanner.images.listTable.filters.label.image')}}</label>
          <div class="filter-input-wrapper">
            <input 
              v-model="filters.imageSearch"
              type="text" 
              :placeholder="t('imageScanner.images.listTable.filters.placeholder.image')"
              class="filter-input"
            />
            <i class="icon icon-search" style="color: #6C6C76; margin-left: 8px;"></i>
          </div>
        </div>
        <div class="filter-item">
          <label>{{ t('imageScanner.images.listTable.filters.label.severity') }}</label>
          <LabeledSelect
            v-model:value="filters.severitySearch"
            :options="severityOptions"
            :close-on-select="true"
            :multiple="false"
          />
        </div>
        <div class="filter-item">
          <label>{{ t('imageScanner.images.listTable.filters.label.repository') }}</label>
          <LabeledSelect
            v-model:value="filters.repositorySearch"
            :options="repositoryOptions"
            :close-on-select="true"
            :multiple="false"
          />
        </div>
        <div class="filter-item">
          <label>{{ t('imageScanner.images.listTable.filters.label.registry') }}</label>
          <LabeledSelect
            v-model:value="filters.registrySearch"
            :options="registryOptions"
            :close-on-select="true"
            :multiple="false"
          />
        </div>
      </div>
    </div>
    <SortableTable
      :headers="isGrouped ? REPO_BASED_TABLE : IMAGE_LIST_TABLE"
      :namespaced="false"
      :search="false"
      :paging="true"
      :row-actions="!isGrouped"
      :table-actions="true"
      :sub-expandable="isGrouped"
      :sub-rows="isGrouped"
      :sub-expand-column="isGrouped"
      :rows="isGrouped ? preprocessedDataset.rowsByRepo : rows"
      :key-field="'id'"
      @selection="onSelectionChange"
    >
      <template #header-left>
        <div class="table-top-left">
          <DownloadCustomReport
            class="table-btn" 
            :selectedRows="selectedRows"
            :buttonName="t('imageScanner.images.buttons.downloadCustomReport')"
          />
        </div>
      </template>
      <template #header-right>
        <div class="table-top-right">
          <Checkbox 
            style="margin-top: 8px; width: 180px;"
            label-key="imageScanner.images.listTable.checkbox.groupByRepo"
            v-model:value="isGrouped"
            @update:value="updateData($event)"
          />
        </div>
      </template>
      <template v-if="isGrouped" #sub-row="{ row, fullColspan }">
        <tr
          class="sub-row"
        >
          <td :colspan="fullColspan">
            <SortableTable
              class="sub-table"
              :rows="row.images"
              :headers="REPO_BASED_IMAGE_LIST_TABLE"
              :search="false"
              :row-actions="true"
              :table-actions="false"
            />
          </td>
        </tr>
      </template>
      <template #row-actions="{ row }">
        <ActionMenu :resource="row" :custom-actions="customActions" />
      </template>
    </SortableTable>
  </div>


</template>

<script>
  import SortableTable from "@shell/components/SortableTable";
  import LabeledSelect from "@shell/components/form/LabeledSelect";
  import DownloadCustomReport from "@pkg/components/common/DownloadCustomReport";
  import TopRiskyImagesChart from "@pkg/components/TopRiskyImagesChart";
  import ImageRiskAssessment from "@pkg/components/ImageRiskAssessment";
  import ActionMenu from '@shell/components/ActionMenuShell.vue';
  import { IMAGE_LIST_TABLE, REPO_BASED_TABLE, REPO_BASED_IMAGE_LIST_TABLE } from "@pkg/config/table-headers";
  import { Checkbox } from '@components/Form/Checkbox';
  import { RESOURCE } from "@pkg/types";
  import { saveAs } from 'file-saver';
  import Papa from 'papaparse';
  import { flatten } from 'flat';

  export default {
    name: 'imageOverview',
    components: {
      LabeledSelect,
      TopRiskyImagesChart,
      ImageRiskAssessment,
      SortableTable,
      DownloadCustomReport,
      Checkbox,
      ActionMenu
    },
    data() {
      const filterCveOptions = [
        {
          value: "allCves",
          label: this.t('imageScanner.images.filters.cve.allCves')
        },
        {
          value: "affectingCvesOnly",
          label: this.t('imageScanner.images.filters.cve.affectingCvesOnly')
        },
      ];
      const filterImageOptions = [
        {
          value: "allImages",
          label: this.t('imageScanner.images.filters.image.allImages')
        },
        {
          value: "excludeBaseImages",
          label: this.t('imageScanner.images.filters.image.excludeBaseImages')
        },
        {
          value: "includeBaseImages",
          label: this.t('imageScanner.images.filters.image.includeBaseImages')
        }
      ];
      const severityOptions = [
        {
          value: "any",
          label: this.t('imageScanner.imageDetails.any')
        },
        {
          value: "critical",
          label: this.t('imageScanner.enum.cve.critical')
        },
        {
          value: "high",
          label: this.t('imageScanner.enum.cve.high')
        },
        {
          value: "medium",
          label: this.t('imageScanner.enum.cve.medium')
        },
        {
          value: "low",
          label: this.t('imageScanner.enum.cve.low')
        },
        {
          value: "unknown",
          label: this.t('imageScanner.enum.cve.unknown')
        },
        {
          value: "suppressed",
          label: this.t('imageScanner.enum.cve.suppressed')
        }
      ]
      return {
        rows: [],
        REPO_BASED_TABLE: REPO_BASED_TABLE,
        IMAGE_LIST_TABLE: IMAGE_LIST_TABLE,
        REPO_BASED_IMAGE_LIST_TABLE: REPO_BASED_IMAGE_LIST_TABLE,
        isGrouped: false,
        selectedRows: [],
        preprocessedDataset: {},
        preprocessedImagesBak: [],
        filterCveOptions,
        filterImageOptions,
        severityOptions,
        selectedCveFilter: filterCveOptions[0],
        selectedImageFilter: filterImageOptions[0],
        filters: {
          imageSearch: '',
          severitySearch: severityOptions[0],
          repositorySearch: 'Any',
          registrySearch: 'Any',
        },
        registryCrds: [],
      }
    },
    computed: {
      customActions() {
        const downloadSbom = {
          action:   'downloadSbom',
          label:    this.t('imageScanner.images.buttons.downloadSbom'),
          icon:     'icon-download',
          enabled:  true,
          bulkable: false,
          invoke:   (_, res) => {
            this.downloadSbom(res);
          }
        };
        const downloadCsv = {
          action:   'downloadCsv',
          label:    this.t('imageScanner.images.buttons.downloadCsv'),
          icon:     'icon-download',
          enabled:  true,
          bulkable: false,
          invoke:   (_, res) => {
            this.downloadCsv(res);
          }
        };
        const downloadJson = {
          action:   'downloadJson',
          label:    this.t('imageScanner.images.buttons.downloadJson'),
          icon:     'icon-download',
          enabled:  true,
          bulkable: false,
          invoke:   (_, res) => {
            this.downloadJson(res);
          }
        };
        return [
          downloadSbom, 
          {divider: true},
          downloadCsv,
          downloadJson
        ];
      },
      repositoryOptions() {
        const repoSet = new Set();
        this.registryCrds.forEach(reg => {
          if (reg.spec.repositories && reg.spec.repositories.length) {
            reg.spec.repositories.forEach(repo => repoSet.add(repo));
          }
        });
        return ["Any", ...repoSet];
      },
      registryOptions() {
        return ["Any", ...this.registryCrds.map(reg => `${reg.metadata.namespace}/${reg.metadata.name}`)];
      }
    },
    async fetch() {
      const vulReportCRD = await this.$store.dispatch('cluster/findAll', { type: RESOURCE.VULNERABILITY_REPORT });
      this.preprocessData(vulReportCRD);
      this.preprocessedDataset = this.preprocessData(vulReportCRD);
      this.preprocessedImagesBak = _.cloneDeep(this.preprocessedDataset.preprocessedImages);
      console.log("this.preprocessedDataset", this.preprocessedDataset)
      this.registryCrds = await this.$store.dispatch('cluster/findAll', { type: RESOURCE.REGISTRY });
    },
    methods: {
      async downloadSbom(res) {
        const target = (res && res.length ? res[0] : null);
        const sbom = await this.$store.dispatch('cluster/find', { type: RESOURCE.SBOM, id: target.id });
        const spdxString = JSON.stringify(sbom.spdx, null, 2);
        const sbomBlob = new Blob([spdxString], { type: 'application/json;charset=utf-8' });
        saveAs(sbomBlob, `${sbom.metadata.name}-sbom.spdx.json`);
      },
      async downloadJson(res) {
        const target = (res && res.length ? res[0] : null);
        const vulReport = await this.$store.dispatch('cluster/find', { type: RESOURCE.VULNERABILITY_REPORT, id: target.id });
        const jsonBlob = new Blob([JSON.stringify(vulReport, null, 2)], { type: 'application/json;charset=utf-8' });
        saveAs(jsonBlob, `${target.id}-vul-report.json`);
      },
      async downloadCsv(res) {
        const target = (res && res.length ? res[0] : null);
        const vulReport = await this.$store.dispatch('cluster/find', { type: RESOURCE.VULNERABILITY_REPORT, id: target.id });
        const csvString = JSON.stringify(vulReport.report.results[0].vulnerabilities.map(vul => flatten(vul)));
        const csvBlob = new Blob([Papa.unparse(csvString)], { type: 'text/csv;charset=utf-8' });
        saveAs(csvBlob, `${target.id}-image-detail-report.csv`);
      },
      applyFilters() {
        let filtered = _.cloneDeep(this.preprocessedImagesBak);
        if (this.selectedImageFilter.value === "excludeBaseImages" || this.selectedImageFilter === "excludeBaseImages") {
          filtered = filtered.filter(image => !image.spec.isBaseImage);
        } else if (this.selectedImageFilter.value === "includeBaseImages" || this.selectedImageFilter === "includeBaseImages") {
          filtered = filtered.filter(image => image.spec.isBaseImage);
        }
        if (this.selectedCveFilter.value === "affectingCvesOnly" || this.selectedCveFilter === "affectingCvesOnly") {
          filtered = filtered.filter(image => image.spec.hasAffectedPackages);
        }
        this.preprocessedDataset = this.preprocessData(filtered);
      },

      changeImageFilter(selectedImageFilter) {
        this.selectedImageFilter = selectedImageFilter;
        this.applyFilters();
      },

      changeCveFilter(selectedCveFilter) {
        this.selectedCveFilter = selectedCveFilter;
        this.applyFilters();
      },
      filterBySeverity(severity) {
        this.preprocessedDataset.preprocessedImages = _.cloneDeep(this.preprocessedImagesBak);
        if (severity) {
          this.preprocessedDataset.preprocessedImages = this.preprocessedDataset.preprocessedImages.filter(image => (image.severity.toLowerCase() === severity.toLowerCase()));
        }
      },
      onSelectionChange(selected) {
        this.selectedRows = selected || [];
      },
      preprocessData(vulReportCRD) {
        this.rows = [];
        vulReportCRD.forEach(report => {
          this.rows.push({
            id: report.id,
            metadata: {
              name: report.metadata.name,
            },
            imageMetadata: report.imageMetadata,
            spec: {
              isBaseImage: true,
              hasAffectedPackages: false,
              repository: report.imageMetadata.repository,
              registry: report.imageMetadata.registryURI,
              scanResult: report.report.summary,
            }
          });
        });
        const severityKeys = ['critical', 'high', 'medium', 'low', 'unknown'];
        const repoMap = new Map();
        const preprocessedImages = [];

        this.rows.forEach(image => {
          let repoRec = {};
          let imageSeverity = "";
          const mapKey = `${image.spec.repository},${image.spec.registry}`;
          const currImageScanResult = {};
          for (const key of severityKeys) {
            currImageScanResult[key] = image.spec.scanResult[key];
            if (!imageSeverity) {
              imageSeverity = (image.spec.scanResult[key] || 0) > 0 ? key : "";
            }
          }
          if (repoMap.has(mapKey)) {
            const currRepo = repoMap.get(mapKey);
            for (const key of severityKeys) {
              currRepo.cveCntByRepo[key] += image.spec.scanResult[key];
            }
            currRepo.images.push(
              {
                metadata: { name: image.metadata.name },
                imageMetadata: image.imageMetadata,
                scanResult: currImageScanResult,
              }
            );
            repoMap.set(mapKey, currRepo);
          } else {
            repoRec = {
              id: mapKey,
              repository: image.spec.repository,
              registry: image.spec.registry,
              cveCntByRepo: currImageScanResult,
              images: [
                {
                  metadata: { name: image.metadata.name },
                  imageMetadata: image.imageMetadata,
                  scanResult: currImageScanResult,
                }
              ]
            }
            repoMap.set(mapKey, repoRec);
          }
          preprocessedImages.push({
            ...image,
            severity: imageSeverity || "none",
          });
          return {
            imageName: image.metadata.name,
            mageMetadata: image.imageMetadata,
            cveCnt: image.spec.scanResult,
          }
        });
        return {
          preprocessedImages,
          rowsByRepo: Array.from(repoMap.values())
        };
      },
      updateData(event) {
        console.log("isGrouped", this.isGrouped);
      },
    },
  }

</script>


<style scoped>
  .page {
    display: flex;
    flex-direction: column;
    padding: 24px;
    min-height: 100%;
  }
  .header-section {
    display: flex;
    align-items: flex-start;
    gap: 16px;
    align-self: stretch;
    border-radius: 6px;
    .title {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: flex-start;
      gap: 4px;
      flex: 1 0 0;
      color: #141419;
      font-family: Lato;
      font-size: 24px;
      font-style: normal;
      font-weight: 400;
      line-height: 32px; /* 133.333% */
    }
    .filter-dropdown {
      display: flex;
      width: 225px;
      height: 40px;
    }
  }
  .summary-section {
    display: flex;
    align-items: flex-start;
    align-self: stretch;
    border-radius: 6px;
    border: 1px solid #DCDEE7;
    background: #FFF;
    margin: 24px 0;
  }
  .table-filter-section {
    display: flex;
    align-items: flex-start;
    gap: 16px;
    align-self: stretch;
    .table-filter {
      justify-content: center;
      align-items: flex-start;
      gap: 4px;
      flex: 1 0 0;
      .title {
        display: -webkit-box;
        -webkit-box-orient: vertical;
        -webkit-line-clamp: 1;
        align-self: stretch;
        overflow: hidden;
        color: #6C6C76;
        text-overflow: ellipsis;
        font-family: Lato;
        font-size: 14px;
        font-style: normal;
        font-weight: 400;
        line-height: 21px; /* 150% */
      }
    }
  }

  .filter-row {
    display: flex;
    gap: 24px;
    margin-bottom: 20px;
  }

  .filter-item {
    display: flex;
    flex-direction: column;
    gap: 8px;
    flex: 1;
  }

  .filter-item label {
    font-weight: 400;
    color: #6C6C76;
    font-size: 14px;
  }

  .filter-input-wrapper {
    display: flex;
    align-items: center;
    border: 1px solid #DCDEE7;
    border-radius: 6px;
    padding: 0 12px;
    background: #FFF;
  }

  .filter-input {
    flex: 1;
    padding: 10px 0;
    border: none;
    outline: none;
    font-size: 14px;
    line-height: 19px;
    background: transparent;
  }

  .score-input {
    color: #BEC1D2;
  }

  .score-input::placeholder {
    color: #BEC1D2;
  }

  .filter-input:focus {
    outline: none;
  }

  .filter-input-wrapper:focus-within {
    border-color: #007cba;
    box-shadow: 0 0 0 2px rgba(0, 124, 186, 0.1);
  }

  .filter-select {
    padding: 10px 14px;
    border: 1px solid #DCDEE7;
    border-radius: 6px;
    font-size: 14px;
    background: #FFF;
    outline: none;
  }

  .filter-select:focus {
    border-color: #007cba;
    box-shadow: 0 0 0 2px rgba(0, 124, 186, 0.1);
  }

  .filter-actions {
    display: flex;
    justify-content: flex-start;
    align-items: center;
    gap: 8px;
    padding-top: 16px;
    border-top: 1px solid #DCDEE7;
  }

</style>