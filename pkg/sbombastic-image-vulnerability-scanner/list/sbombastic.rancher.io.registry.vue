<template>
  <div>
    <div class="state">State as of <span class="state-date-time">{{ latestUpdateTimeText }}</span></div>
    <div class="summary-section">
      <RecentUpdatedRegistries :registryStatusList="registryStatusList"/>
      <StatusDistribution :chartData="statusSummary"/>
    </div>
    <button
      mat-button
      class="btn role-secondary"
      style="margin-bottom: 12px;"
      aria-label="Refresh data"
      type="button"
      @click="startScan()">
      <em class="icon-refresh-ss"></em>{{ t('imageScanner.registries.button.startScan') }}
    </button>
    <ResourceTable
      ref="table"
      :schema="schema"
      :has-advanced-filtering="true"
      :rows="rows"
      :headers="headers"
      @selection="onSelectionChange"
    />
  </div>
</template>

<script>

  import { ref } from "vue";
  import { RESOURCE } from "@sbombastic-image-vulnerability-scanner/types";
  import ResourceTable from "@shell/components/ResourceTable";
  import RecentUpdatedRegistries from "@sbombastic-image-vulnerability-scanner/components/RecentUpdatedRegistries";
  import StatusDistribution from "@sbombastic-image-vulnerability-scanner/components/StatusDistribution";
  import { REGISTRY_SCAN_TABLE } from "@sbombastic-image-vulnerability-scanner/config/table-headers";
  import {
    PRODUCT_NAME,
  } from "@sbombastic-image-vulnerability-scanner/types";
  import { escapeHtml } from '@shell/utils/string';
  import day from 'dayjs';
  import { DATE_FORMAT, TIME_FORMAT } from '@shell/store/prefs';

  export default {
    name: 'registries',
    components: {
      ResourceTable,
      RecentUpdatedRegistries,
      StatusDistribution
    },
    data() {
      return {
        content: ref("Registries"),
        PRODUCT_NAME: PRODUCT_NAME,
        rows: [],
        registryStatusList: [],
        latestUpdateTime: null,
        statusSummary: {
          scheduled: 0,
          pending: 0,
          inprogress: 0,
          complete: 0,
          failed: 0
        },
        headers: REGISTRY_SCAN_TABLE,
      }
    },

    async fetch() {
      await this.$store.dispatch('cluster/findAll', { type: RESOURCE.REGISTRY });
      if (this.$store.getters['cluster/canList'](RESOURCE.SCAN_JOB)) {
        await this.$store.dispatch('cluster/findAll', { type: RESOURCE.SCAN_JOB });
      }
      this.loadData();
    },
    methods: {
      loadData() {
        this.registryStatusList = [];
        this.statusSummary = {
          scheduled: 0,
          pending: 0,
          inprogress: 0,
          complete: 0,
          failed: 0
        };
        this.latestUpdateTime = null;
        
        let registriesCRD = this.$store.getters['cluster/all'](RESOURCE.REGISTRY);
        let scanJobCRD = this.$store.getters['cluster/all'](RESOURCE.SCAN_JOB).sort((a, b) => {
          if (!a.status || !a.status.startTime) {
            return 1;
          }
          if (!b.status || !b.status.startTime) {
            return -1;
          }
          return new Date(b.status.startTime) - new Date(a.status.startTime);
        });

        let scanJobMap = {};
        scanJobCRD.forEach((rec) => {
          rec.status.statusResult = rec.status.conditions.filter(condition => {
            return condition.status === "True";
          })[0] || {
            type: "Pending",
            lastUpdateTime: null,
          };
          if (scanJobMap[`${rec.metadata.namespace}/${rec.spec.registry}`]) {
            scanJobMap[`${rec.metadata.namespace}/${rec.spec.registry}`].push(rec);
          } else {
            scanJobMap[`${rec.metadata.namespace}/${rec.spec.registry}`] = [rec];
          }
        });

        this.rows = registriesCRD.map((rec) => {
          this.latestUpdateTime = new Date();
          rec.id = `${rec.metadata.namespace}/${rec.metadata.name}`;
          rec.scanjobs = scanJobMap[`${rec.metadata.namespace}/${rec.metadata.name}`] || [];
          const status = rec.scanjobs?.[0]?.status?.statusResult?.type?.toLowerCase() || 'pending';
          const prevStatus = rec.scanjobs?.[1]?.status?.statusResult?.type?.toLowerCase() || 'pending';
          this.registryStatusList.push({
            registry_name: rec.metadata.name,
            uri: rec.spec.uri,
            namespace: rec.metadata.namespace,
            prev_status: prevStatus,
            curr_status: status,
            last_update_time: rec.scanjobs?.[0]?.status?.statusResult?.lastUpdateTime || rec.metadata.creationTimestamp,
          });
          if (status && this.statusSummary.hasOwnProperty(status)) {
            this.statusSummary[status]++;
          }
          return rec;
        });

        this.registryStatusList.sort((a, b) => new Date(b.last_update_time) - new Date(a.last_update_time)).slice(0, 5)
        while (this.registryStatusList.length < 5) {
          this.registryStatusList.push({
            registry_name: "",
            uri: "",
            prev_status: "",
            curr_status: "",
            last_update_time: new Date().toISOString()
          });
        }
      },
      refresh() {
        window.location.reload();
      },
      async startScan() {
        const table = this.$refs.table;
        if ( !table ) {
          return;
        }
        const scanjobObj = await this.$store.dispatch('cluster/create', {
          type: RESOURCE.SCAN_JOB,
          metadata: {
            generateName: this.selectedRows[0].metadata.name,
            namespace: this.selectedRows[0].metadata.namespace,
          },
          spec: {
            registry: this.selectedRows[0].metadata.name,
          }
        });
        try {
          await scanjobObj.save();
          this.loadData();
          this.$store.dispatch('growl/success', {
            title: this.t('imageScanner.registries.messages.registryScanComplete'),
            message: this.t('imageScanner.registries.messages.registryScanComplete', { name: selection[0].metadata.name }),
          });
        } catch (e) {
          this.$store.dispatch('growl/error', {
            title: this.t('imageScanner.registries.messages.registryScanFailed'),
            message: e.message,
          });
        }
      },
      openAddEditRegistry() {},
      onSelectionChange(selected) {
        this.selectedRows = selected || [];
      },
    },
    computed: {
      schema() {
        return this.$store.getters['cluster/schemaFor'](RESOURCE.SCAN_JOB);
      },
      latestUpdateTimeText() {
        const dateFormat = escapeHtml( this.$store.getters['prefs/get'](DATE_FORMAT));
        const timeFormat = escapeHtml( this.$store.getters['prefs/get'](TIME_FORMAT));
        return `${day(new Date(this.latestUpdateTime).getTime()).format(dateFormat)} ${day(new Date(this.latestUpdateTime).getTime()).format(timeFormat)}`;
      },
    }
  }

</script>


<style lang="scss" scoped>
  .page {
    display: flex;
    flex-direction: column;
    padding: 0 20px 20px 20px;
    min-height: 100%;
  }
  .header-section {
    display: flex;
    align-items: flex-start;
    gap: 24px;
    align-self: stretch;
    margin-bottom: 24px;
    .header-left {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: flex-start;
      gap: 4px;
      flex: 1 0 0;
    }
    .title-wrap {
      display: flex;
      align-items: center;
      gap: 12px;
      align-self: stretch;
      .title {
        color: #141419;
        font-family: Lato;
        font-size: 24px;
        font-style: normal;
        font-weight: 600;
        line-height: 32px; /* 133.333% */
      }
      .state {
        display: -webkit-box;
        max-width: 900px;
        -webkit-box-orient: vertical;
        -webkit-line-clamp: 1;
        align-self: stretch;
        overflow: hidden;
        color: #717179;

        text-overflow: ellipsis;
        font-family: Lato;
        font-size: 14px;
        font-style: normal;
        font-weight: 400;
        line-height: 21px; /* 150% */

        .state-date-time {
          overflow: hidden;
          -webkit-box-orient: vertical;
          -webkit-line-clamp: 1;
          color: #717179;
          text-overflow: ellipsis;
          font-family: Lato;
          font-size: 14px;
          font-style: normal;
          font-weight: 600;
          line-height: 21px;
        }
      }
    }
    .header-right {
      display: flex;
      align-items: flex-end;
      justify-content: end;
      flex: 1 0 0;
      gap: 24px;
    }
    .header-btn {
      height: 40px;
    }
    .icon-add {
      width: 16px;
      height: 16px;
      margin-right: 12px;
      background: url('../assets/img/add.svg') no-repeat center center;
      background-size: contain;
    }
    .icon-refresh-ss {
      width: 16px;
      height: 16px;
      margin-right: 12px;
      background: url('../assets/img/refresh.svg') no-repeat center center;
      background-size: contain;
    }
  }
  .summary-section {
    display: flex;
    min-width: 912px;
    align-items: flex-start;
    align-self: stretch;
    border-radius: 6px;
    border: 1px solid #DCDEE7;
    background: #FFF;
    margin: 24px 0;
  }
   
</style>