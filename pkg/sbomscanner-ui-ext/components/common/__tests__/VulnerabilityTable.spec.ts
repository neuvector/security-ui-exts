import { shallowMount, mount } from '@vue/test-utils';
import VulnerabilityTable from '../VulnerabilityTable.vue';
import { downloadCSV } from '../../../utils/report';
import { decodeBase64 } from '../../../utils//app';
const day = require('dayjs');

// Mock external modules
jest.mock('@pkg/utils/report', () => ({
  downloadCSV: jest.fn(),
}));
jest.mock('@pkg/utils/app', () => ({
  decodeBase64: jest.fn((input) => `decoded(${input})`),
}));
// dayjs must be a callable function (default import). Return object with .format(fmt)
jest.mock('dayjs', () => jest.fn((input) => {
  return {
    format: (fmt) => {
      if (fmt === 'MMM D, YYYY') return 'Oct 30, 2025';
      if (fmt === 'h:mm a') return '3:45 pm';
      if (fmt === 'MMDDYYYY_HHmmss') return '10302025_1545';
      return 'FORMATTED';
    }
  };
}));

// Simple stubs for child components used in the template
const SortableTableStub = {
  name: 'SortableTable',
  props: ['rows', 'headers', 'keyField'],
  render(h) {
    return h('div', { class: 'sortable-table-stub' });
  },
};
const CheckboxStub = {
  name: 'Checkbox',
  props: ['value', 'labelKey'],
  render(h) {
    return h('input');
  },
};

describe('VulnerabilityTable.vue (Vue2)', () => {
  let wrapper: any;
  let storeMock: any;

  const sampleVulns = [
    {
      id: '1',
      cveId: 'CVE-111',
      severity: 'High',
      score: '9.8',
      package: 'openssl',
      fixVersion: '1.1.1',
      exploitability: 'available',
      installedVersion: '1.1.0',
      packagePath: '/usr/lib/openssl',
      description: 'Test vuln 1',
      diffID: 'sha256:abcdef1234567890',
    },
    {
      id: '1',
      cveId: 'CVE-121',
      severity: 'Medium',
      score: '7.6',
      package: 'pip',
      fixVersion: '1.1.1',
      exploitability: 'available',
      installedVersion: '1.1.0',
      packagePath: '/usr/lib/openssl',
      description: 'Test vuln 1',
      diffID: 'sha256:abcdef1234567890',
    },
    {
      id: '2',
      cveId: 'CVE-222',
      severity: 'LOW',
      score: '2.1',
      package: 'nginx',
      fixVersion: '',
      exploitability: 'available',
      installedVersion: '1.2.3',
      packagePath: '/usr/bin/nginx',
      description: 'Test vuln 2',
      diffID: 'layer-2',
    },
  ];

  beforeEach(() => {
    jest.clearAllMocks();

    storeMock = {
      dispatch: jest.fn(),
    };

    wrapper = shallowMount(VulnerabilityTable, {
        stubs: {
            SortableTable: SortableTableStub,
            Checkbox: CheckboxStub,
        },
        propsData: {
            cachedFilteredVulnerabilities: sampleVulns,
            imageName: 'test-image',
            currentImage: {}, // default, tests override where needed
        },
        global:{
            mocks: {
                $store: storeMock,
                t: (key) => key, // i18n mock returns key
            },
        }
    });
  });

  afterEach(() => {
    jest.clearAllMocks()
  })

  it('mounts and initializes data properly', () => {
    expect(wrapper.exists()).toBe(true);
    expect(wrapper.vm.isGrouped).toBe(false);
    expect(wrapper.vm.layerData).toEqual([]);
    expect(wrapper.vm.VULNERABILITY_DETAILS_TABLE).toBeDefined();
    expect(wrapper.vm.LAYER_BASED_TABLE).toBeDefined();
  });

  it('computed filteredVulnerabilities returns prop value', () => {
    expect(wrapper.vm.filteredVulnerabilities).toEqual(sampleVulns);
  });

  it('safeTableData filters out invalid entries', async () => {
    wrapper.setProps({ cachedFilteredVulnerabilities: [...sampleVulns, null, 42, {}] });
    await wrapper.vm.$nextTick();
    const safe = wrapper.vm.safeTableData;
    // Only objects with id should remain (2)
    expect(safe).toHaveLength(3);
    expect(safe.every(i => i && i.id)).toBe(true);
  });

  it('selectedVulnerabilityCount reflects selectedVulnerabilities length', () => {
    wrapper.setData({ selectedVulnerabilities: [sampleVulns[0]] });
    expect(wrapper.vm.selectedVulnerabilityCount).toBe(1);
  });

  describe('watcher: isGrouped', () => {
    it('clears selectedVulnerabilities and calls vulnerabilitiesByLayer when toggled on', async () => {
      const spy = jest.spyOn(wrapper.vm, 'vulnerabilitiesByLayer');
      // set isGrouped true
      wrapper.setData({ isGrouped: true });
      await wrapper.vm.$nextTick();
      expect(wrapper.vm.selectedVulnerabilities).toEqual([]);
      expect(spy).toHaveBeenCalledWith(sampleVulns, wrapper.vm.currentImage);
    });
     it('clears selectedVulnerabilities and calls vulnerabilitiesByLayer when toggled on - cachedFilteredVulnerabilities, currentImage are undefined', async () => {
      await wrapper.setProps({ cachedFilteredVulnerabilities: undefined });
      await wrapper.setProps({ currentImage: undefined });
      const spy = jest.spyOn(wrapper.vm, 'vulnerabilitiesByLayer');
      // set isGrouped true
      wrapper.setData({ isGrouped: true });
      await wrapper.vm.$nextTick();
      expect(wrapper.vm.selectedVulnerabilities).toEqual([]);
      expect(spy).toHaveBeenCalledWith([], wrapper.vm.currentImage);
    });
  });

  describe('onSelectionChange', () => {
    it('sets selectedVulnerabilities to selection when ungrouped', async () => {
      await wrapper.vm.onSelectionChange([sampleVulns[0]]);
      expect(wrapper.vm.selectedVulnerabilities).toEqual([sampleVulns[0]]);
    });

    it('when grouped, flattens selected layers into vulnerabilities', async () => {
      wrapper.setData({ isGrouped: true });
      const layerSelection = [{ vulnerabilityList: [sampleVulns[0], sampleVulns[1]] }];
      await wrapper.vm.onSelectionChange(layerSelection);
      expect(wrapper.vm.selectedVulnerabilities).toEqual([sampleVulns[0], sampleVulns[1]]);
    });

    it('handles internal error by setting selectedVulnerabilities to []', async () => {
      // Force an error to be thrown inside the try block by mocking Array.isArray to throw
      const originalIsArray = Array.isArray;
      jest.spyOn(Array, 'isArray').mockImplementation(() => false );

      await wrapper.vm.onSelectionChange([sampleVulns[0]]);
      expect(wrapper.vm.selectedVulnerabilities).toEqual([]);

      // restore
      Array.isArray.mockRestore();
      // sanity check: restore working
      expect(Array.isArray([1,2])).toBe(true);
    });
  });

  describe('onSubTableSelectionChange', () => {
    it('replaces selectedVulnerabilities with sub-table selections when grouped', async () => {
      wrapper.setData({ isGrouped: true });
      await wrapper.vm.onSubTableSelectionChange([sampleVulns[1]]);
      expect(wrapper.vm.selectedVulnerabilities).toEqual([sampleVulns[1]]);
    });
  });

  describe('vulnerabilitiesByLayer(currentImage) grouping', () => {
    it('groups vulnerabilities by diffID and includes layers from currentImage', () => {
      const currentImage = {
        layers: [
          { diffID: 'sha256:abcdef1234567890', command: 'Y21k', size: 2048 },
          { diffID: 'layer-2', digest: 'layer-2-digest', size: 4096 },
          { diffID: 'orphan-layer' },
        ],
        metadata: { creationTimestamp: new Date().toISOString() },
        imageMetadata: { size: 1048576 },
      };

      // Mount a fresh wrapper with currentImage
      const w = shallowMount(VulnerabilityTable, {
        stubs: { SortableTable: SortableTableStub, Checkbox: CheckboxStub },
        mocks: { $store: storeMock, t: (k) => k },
        propsData: {
          cachedFilteredVulnerabilities: sampleVulns,
          imageName: 'img',
          currentImage,
        },
      });

      const layers = w.vm.vulnerabilitiesByLayer(sampleVulns, currentImage);
      // We expect layers to include at least the map keys for sample diffIDs and orphan-layer
      const ids = layers.map(l => l.id);
      expect(ids).toEqual(expect.arrayContaining(['sha256:abcdef1234567890', 'layer-2', 'orphan-layer']));
      // vulnerabilityList lengths should match grouped items
      const shaLayer = layers.find(l => l.id === 'sha256:abcdef1234567890');
      expect(shaLayer.vulnerabilityList.length).toBeGreaterThanOrEqual(1);
    });

    it('returns [] when invalid vulnerabilityReport provided', () => {
      const res = wrapper.vm.vulnerabilitiesByLayer(null, {});
      expect(res).toEqual([]);
    });
  });

  describe('decodeLayerId', () => {
    it('returns Unknown Layer for falsy/unknown id', () => {
      expect(wrapper.vm.decodeLayerId('')).toBe('Unknown Layer');
      expect(wrapper.vm.decodeLayerId(undefined)).toBe('Unknown Layer');
    });

    it('decodes sha256 id using currentImage layers command via decodeBase64', async () => {
      const currentImage = {
        layers: [
            { diffID: 'sha256:abcdef1234567890', command: 'Y21k' },
        ],
      };
      await wrapper.setProps({ currentImage });
      const res = wrapper.vm.decodeLayerId('sha256:abcdef1234567890');
      
      expect(decodeBase64).toHaveBeenCalledWith('Y21k');
      expect(res).toContain('decoded(');
    });

    it('decodes sha256 id using currentImage layers command via decodeBase64 - currentImage.layerId does not match diffId in vulnerabilities report', async () => {
      const currentImage = {
        layers: [
            { diffID: 'sha256:abcdef1234567890', command: 'sha256:abcdef1234567890' },
        ],
      };
      await wrapper.setProps({ currentImage });
      const res = wrapper.vm.decodeLayerId('sha256:abcdef123456789');
      expect(decodeBase64).not.toHaveBeenCalledWith('abcdef1234567890');
      expect(res).toContain('decoded(');
    });

    it('parses pkg: purl and returns package@version', () => {
      const res = wrapper.vm.decodeLayerId('pkg:npm/vue@2.6.14');
      expect(res).toBe('vue@2.6.14');
    });

    it('truncates long ids', () => {
      const long = 'a'.repeat(60);
      expect(wrapper.vm.decodeLayerId(long).endsWith('...')).toBe(true);
    });
  });

  describe('formatVulnerabilityCounts', () => {
    it('maps counts and maps none to unknown', () => {
      const out = wrapper.vm.formatVulnerabilityCounts({ critical: 1, high: 2, medium: 3, low: 4, none: 5 });
      expect(out).toEqual({ critical: 1, high: 2, medium: 3, low: 4, unknown: 5 });
    });

    it('returns zeros when undefined passed', () => {
      const out = wrapper.vm.formatVulnerabilityCounts(null);
      expect(out.critical).toBe(0);
      expect(out.unknown).toBe(0);
    });
  });

  describe('getLayerUpdatedTime', () => {
    it('returns formatted string when currentImage.metadata exists', async () => {
      const now = new Date().toISOString();
      await wrapper.setProps({ currentImage: { metadata: { creationTimestamp: now } } });
      const res = wrapper.vm.getLayerUpdatedTime('anything');
      expect(res).toContain('Oct 30, 2025 3:45 pm');
    });

    it('returns i18n unknown when no metadata', async () => {
      await wrapper.setProps({ currentImage: {} });
      const res = wrapper.vm.getLayerUpdatedTime('id');
      expect(res).toBe(wrapper.vm.t('imageScanner.general.unknown'));
    });
  });

  describe('getLayerSize', () => {
    it('returns MB if layer.size numeric present', async () => {
      await wrapper.setProps({
        currentImage: {
          layers: [{ diffID: 'layer-2', size: 1048576 }],
        },
      });
      const res = wrapper.vm.getLayerSize('layer-2');
      expect(res).toContain('MB');
    });

      it('returns MB if layer.size numeric present - size is not number', async () => {
      await wrapper.setProps({
        currentImage: {
          layers: [{ diffID: 'layer-2', size: '104MB' }],
        },
      });
      const res = wrapper.vm.getLayerSize('layer-2');
      expect(res).toContain('104MB');
    });

    it('falls back to i18n unknown when nothing matches', () => {
      wrapper.setProps({ currentImage: {} });
      const res = wrapper.vm.getLayerSize('no-match');
      expect(res).toBe(wrapper.vm.t('imageScanner.general.unknown'));
    });
  });

  describe('downloadCustomReport', () => {
    it('generates CSV and calls downloadCSV and error growl when selectedVulnerabilities empty (per current code logic)', () => {
      // Note: the component uses `if (!this.selectedVulnerabilities.length === 0)` which is a bug; with empty selection it proceeds to generate CSV.
      wrapper.setData({ selectedVulnerabilities: [] });
      wrapper.vm.downloadCustomReport();
      expect(downloadCSV).not.toHaveBeenCalled();
      expect(storeMock.dispatch).toHaveBeenCalledWith('growl/error', expect.objectContaining({ title: 'Error' }), { root: true });
    });

    it('handles generateCSV errors by dispatching growl error', () => {
      // Force generateCSVFromFilteredVulnerabilities to throw
      jest.spyOn(wrapper.vm, 'generateCSVFromFilteredVulnerabilities').mockImplementation(() => { throw new Error('boom'); });
      wrapper.setData({ selectedVulnerabilities: [sampleVulns[0]] });
      wrapper.vm.downloadCustomReport();
      expect(storeMock.dispatch).toHaveBeenCalledWith('growl/error', expect.objectContaining({ title: 'Error' }), { root: true });
      // restore the mocked method
      wrapper.vm.generateCSVFromFilteredVulnerabilities.mockRestore && wrapper.vm.generateCSVFromFilteredVulnerabilities.mockRestore();
    });
  });

  describe('generateCSVFromFilteredVulnerabilities', () => {
    it('uses selectedVulnerabilities when present to create CSV', () => {
      wrapper.setData({ selectedVulnerabilities: [sampleVulns[0]] });
      const csv = wrapper.vm.generateCSVFromFilteredVulnerabilities();
      expect(csv).toContain('CVE_ID');
      expect(csv).toContain('CVE-111');
      expect(csv.split('\n').length).toBeGreaterThan(1);
    });

    it('falls back to filteredVulnerabilities when selection empty', () => {
      wrapper.setData({ selectedVulnerabilities: [] });
      const csv = wrapper.vm.generateCSVFromFilteredVulnerabilities();
      // Should contain both CVE rows for sampleVulns
      expect(csv).toContain('CVE-111');
      expect(csv).toContain('CVE-222');
    });

    it('escapes double quotes and newlines in description', () => {
        sampleVulns[0].description = 'desc with "quotes" and \n new line';
      const vuln = { ...sampleVulns[0]};
      wrapper.setProps({ cachedFilteredVulnerabilities: [vuln] });
      wrapper.setData({ selectedVulnerabilities: [] });
      const csv = wrapper.vm.generateCSVFromFilteredVulnerabilities();
      expect(csv).not.toContain('\"quotes\"');
      expect(csv).toContain('\'quotes\'');
      expect(csv).toContain('new line');
    });
  });
});
