import VulnerabilityReport from '../storage.sbomscanner.kubewarden.io.vulnerabilityreport';

// Minimal mock SteveModel superclass to satisfy prototype chain
class MockSteveModel {
  [key: string]: any;

  constructor(data: Record<string, any> = {}) {
    Object.assign(this, data);
  }

  get _availableActions(): Array<{ action?: string }> {
    return [
      { action: 'download' },
      { action: 'downloadYaml' },
      { action: 'viewYaml' },
      { action: 'goToViewYaml' },
      { action: 'viewInApi' },
      { action: 'showConfiguration' },
      { action: 'editYaml' },
      { action: 'clone' },
      { action: 'customAction' }
    ];
  }
}

describe('VulnerabilityReport model', () => {
  const origProto = Object.getPrototypeOf((VulnerabilityReport as any).prototype);

  beforeAll(() => {
    // Replace prototype with mock
    Object.setPrototypeOf((VulnerabilityReport as any).prototype, MockSteveModel.prototype);
  });

  afterAll(() => {
    // Restore prototype
    Object.setPrototypeOf((VulnerabilityReport as any).prototype, origProto);
  });

  test('filters available actions', () => {
    const inst = Object.create((VulnerabilityReport as any).prototype);
    const actions = inst._availableActions;

    expect(Array.isArray(actions)).toBe(true);
    // Ensure removed actions are not present
    expect(actions.find((a: any) => a.action === 'download')).toBeUndefined();
    expect(actions.find((a: any) => a.action === 'editYaml')).toBeDefined();
    expect(actions.find((a: any) => a.action === 'clone')).toBeDefined();
  });

  test('listLocation, doneOverride and parentLocationOverride', () => {
    const inst = Object.create((VulnerabilityReport as any).prototype);
    expect(inst.listLocation).toHaveProperty('name');
    expect(inst.doneOverride).toEqual(inst.listLocation);
    expect(inst.parentLocationOverride).toEqual(inst.listLocation);
  });

  test('reportData parses JSON string and returns object', () => {
    const inst = Object.create((VulnerabilityReport as any).prototype);
    inst.report = JSON.stringify({ results: [{ vulnerabilities: [ { cve: 'CVE-1' } ] }] });

    expect(inst.reportData).toBeDefined();
    expect(Array.isArray(inst.reportData.results)).toBe(true);

    // invalid JSON
    inst.report = '{ bad json }';
    expect(inst.reportData).toBeNull();
  });

  test('vulnerabilities getter handles missing or empty results', () => {
    const inst = Object.create((VulnerabilityReport as any).prototype);
    inst.report = null;
    expect(inst.vulnerabilities).toEqual([]);

    inst.report = JSON.stringify({ results: [] });
    expect(inst.vulnerabilities).toEqual([]);

    inst.report = JSON.stringify({ results: [{ vulnerabilities: [{ cve: 'CVE-1'}] }] });
    expect(inst.vulnerabilities.length).toBe(1);
  });

  test('severityDistribution, totalVulnerabilities and overallSeverity', () => {
    const inst = Object.create((VulnerabilityReport as any).prototype);

    inst.report = JSON.stringify({
      results: [{
        vulnerabilities: [
          { cve: 'CVE-1', severity: 'Critical' },
          { cve: 'CVE-2', severity: 'High' },
          { cve: 'CVE-3', severity: 'Medium' },
          { cve: 'CVE-4', severity: 'Low' },
          { cve: 'CVE-5', severity: 'None' },
          { cve: 'CVE-6', severity: 'Unknown' }
        ]
      }]
    });

    const dist = inst.severityDistribution;
    expect(dist.critical).toBe(1);
    expect(dist.high).toBe(1);
    expect(dist.medium).toBe(1);
    expect(dist.low).toBe(1);
    expect(dist.none).toBe(2); // one explicit "None" + one "Unknown"

    expect(inst.totalVulnerabilities).toBe(6);
    expect(inst.overallSeverity).toBe('critical');
  });

  test('overallSeverity returns "none" when there are no vulnerabilities', () => {
    const inst = Object.create((VulnerabilityReport as any).prototype);
    inst.report = JSON.stringify({ results: [{ vulnerabilities: [] }] });

    expect(inst.vulnerabilities).toEqual([]);
    expect(inst.severityDistribution).toEqual({ critical: 0, high: 0, medium: 0, low: 0, none: 0 });
    expect(inst.overallSeverity).toBe('none');
  });

  test('reportData returns object when report is already an object', () => {
    const inst = Object.create((VulnerabilityReport as any).prototype);
    const obj = { results: [{ vulnerabilities: [{ cve: 'CVE-OBJ' }] }] };
    inst.report = obj;

    expect(inst.reportData).toBe(obj);
    expect(inst.vulnerabilities.length).toBe(1);
  });

  test('vulnerabilities returns [] when results[0] has no vulnerabilities property', () => {
    const inst = Object.create((VulnerabilityReport as any).prototype);
    inst.report = { results: [ {} ] };

    expect(inst.vulnerabilities).toEqual([]);
  });

  test('severityDistribution counts undefined severity as none', () => {
    const inst = Object.create((VulnerabilityReport as any).prototype);
    inst.report = JSON.stringify({ results: [{ vulnerabilities: [ {}, { severity: null } ] }] });

    const dist = inst.severityDistribution;
    expect(dist.none).toBe(2);
  });

  test('mostSevereVulnerabilities returns empty array when no vulnerabilities present', () => {
    const inst = Object.create((VulnerabilityReport as any).prototype);
    inst.report = JSON.stringify({ results: [{ vulnerabilities: [] }] });

    const top = inst.mostSevereVulnerabilities;
    expect(Array.isArray(top)).toBe(true);
    expect(top.length).toBe(0);
  });

  test('_availableActions handles undefined superclass actions and items without action', () => {
    // Temporarily override the MockSteveModel prototype getter to return undefined
    const mockProto = Object.getPrototypeOf((VulnerabilityReport as any).prototype);
    const desc = Object.getOwnPropertyDescriptor(mockProto, '_availableActions');

    // define a getter that returns undefined
    Object.defineProperty(mockProto, '_availableActions', {
      get() { return undefined; },
      configurable: true
    });

    const inst1 = Object.create((VulnerabilityReport as any).prototype);
    // when superclass _availableActions is undefined, out defaults to [] and filtered result is []
    expect(inst1._availableActions).toEqual([]);

    // Now set superclass _availableActions to an array containing items without action and with removable actions
    Object.defineProperty(mockProto, '_availableActions', {
      get() {
        return [
          {},
          { action: 'download' },
          { action: 'customAction' }
        ];
      },
      configurable: true
    });

    const inst2 = Object.create((VulnerabilityReport as any).prototype);
    const actions = inst2._availableActions;
    // should keep the item without action and the customAction, but remove 'download'
    expect(actions.find((a: any) => !a.action)).toBeDefined();
    expect(actions.find((a: any) => a.action === 'customAction')).toBeDefined();
    expect(actions.find((a: any) => a.action === 'download')).toBeUndefined();

    // Restore original descriptor
    if (desc) {
      Object.defineProperty(mockProto, '_availableActions', desc);
    } else {
      delete (mockProto as any)._availableActions;
    }
  });

  test('_availableActions keeps null/undefined entries and removes downloadyaml variant', () => {
    const mockProto = Object.getPrototypeOf((VulnerabilityReport as any).prototype);
    const originalDesc = Object.getOwnPropertyDescriptor(mockProto, '_availableActions');

    Object.defineProperty(mockProto, '_availableActions', {
      get() {
        return [null, undefined, { action: '' }, { action: 'downloadyaml' }, { action: 'keepMe' }];
      },
      configurable: true
    });

    const inst = Object.create((VulnerabilityReport as any).prototype);
    const actions = inst._availableActions;

    // null/undefined should be preserved (kept because !a?.action is true)
    expect(actions.find((a: any) => a === null || a === undefined)).toBeDefined();
    // empty action ('') is falsy and should be preserved
    expect(actions.find((a: any) => a && a.action === '')).toBeDefined();
    // downloadyaml should be removed
    expect(actions.find((a: any) => a && a.action === 'downloadyaml')).toBeUndefined();
    // keepMe should be present
    expect(actions.find((a: any) => a && a.action === 'keepMe')).toBeDefined();

    // restore
    if (originalDesc) {
      Object.defineProperty(mockProto, '_availableActions', originalDesc);
    } else {
      delete (mockProto as any)._availableActions;
    }
  });

  test('associatedImage matches image via spec.name when metadata.name missing', () => {
    const inst = Object.create((VulnerabilityReport as any).prototype);
    inst.spec = { image: 'spec-match' };
    inst.$rootGetters = { 'i18n/t': (k: string) => k };
    const images = [
      { spec: { name: 'spec-match' } },
      { metadata: { name: 'other' } }
    ];
    inst.$getters = { all: (_arg: string) => images };

    const assoc = inst.associatedImage;
    expect(assoc).toBeDefined();
    expect(assoc.spec.name).toBe('spec-match');
  });

  test('mostSevereVulnerabilities sorted by severity then score', () => {
    const inst = Object.create((VulnerabilityReport as any).prototype);

    inst.report = JSON.stringify({
      results: [{
        vulnerabilities: [
          { cve: 'CVE-1', severity: 'medium', cvss: { nvd: { v3score: '7.2' } } },
          { cve: 'CVE-2', severity: 'critical', cvss: { nvd: { v3score: '9.8' } } },
          { cve: 'CVE-3', severity: 'critical', cvss: { nvd: { v3score: '9.6' } } },
          { cve: 'CVE-4', severity: 'high', cvss: { nvd: { v3score: '8.5' } } },
          { cve: 'CVE-5', severity: 'low', cvss: { nvd: { v3score: '5.0' } } },
          { cve: 'CVE-6', severity: 'critical', cvss: { nvd: { v3score: '8.0' } } }
        ]
      }]
    });

    const top = inst.mostSevereVulnerabilities;
    expect(top.length).toBeLessThanOrEqual(5);
    // First should be the highest critical (9.8)
    expect(top[0].cve).toBe('CVE-2');
    // second critical 9.6
    expect(top[1].cve).toBe('CVE-3');
  });

  test('mostSevereVulnerabilities score tie-breaker for same severity', () => {
    const inst = Object.create((VulnerabilityReport as any).prototype);

    inst.report = JSON.stringify({
      results: [{
        vulnerabilities: [
          { cve: 'CVE-A', severity: 'high', cvss: { nvd: { v3score: '7.0' } } },
          { cve: 'CVE-B', severity: 'high', cvss: { nvd: { v3score: '8.5' } } },
          { cve: 'CVE-C', severity: 'high', cvss: { nvd: { v3score: '6.1' } } },
        ]
      }]
    });

    const top = inst.mostSevereVulnerabilities;
    expect(top[0].cve).toBe('CVE-B');
    expect(top[1].cve).toBe('CVE-A');
    expect(top[2].cve).toBe('CVE-C');
  });

  test('associatedImage and imageReference gracefully handle missing data', () => {
    const inst = Object.create((VulnerabilityReport as any).prototype);
    inst.spec = {};

    expect(inst.associatedImage).toBeNull();

    // If imageMetadata is present but image not found, imageReference should still access imageMetadata
    inst.spec = { image: 'nonexistent' };
    inst.imageMetadata = { registryURI: 'reg', repository: 'repo', tag: 'v1' };
    expect(inst.imageReference).toBe('reg/repo:v1');

    // Now test associatedImage path where spec.image exists and $getters/$rootGetters return matching images
    const inst2 = Object.create((VulnerabilityReport as any).prototype);
    inst2.spec = { image: 'found-image' };
    // root getters: provide i18n/t function under key 'i18n/t'
    inst2.$rootGetters = { 'i18n/t': (k: string) => k };
    // getters: 'all' should return array of images
    const images = [
      { metadata: { name: 'other' }, spec: { name: 'other' } },
      { metadata: { name: 'found-image' }, spec: { name: 'found-image' } },
    ];
    inst2.$getters = { all: (_arg: string) => images };

    const associated = inst2.associatedImage;
    expect(associated).toBeDefined();
    expect(associated.metadata.name).toBe('found-image');
  });
});
